[TOC]

# 一、创建方式的区别

**字面量**/ /，运行效率更高（在编译时创建正则对象），直观

**构造**，在运行时创建正则对象

# 二、实例属性

## 1、与修饰符相关

返回布尔值，表示对应的修饰符是否设置

只读属性： RegExp.prototype.ignoreCase 

只读属性： RegExp.prototype.global

只读属性： RegExp.prototype.multiline

```js
let reg = /a/igm
console.log(reg.ignoreCase)
console.log(reg.global)
console.log(reg.multiline)
```

## 2、与修饰符无关

（1）只读属性： RegExp.prototype.source：返回正则表达式的字符串形式

（2）RegExp.prototype.lastIndex:表示下一次开始搜索的位置，只有在连续搜索的情况下使用有意义

**拓展：**[https://blog.csdn.net/qq_36340642/article/details/79352876](https://blog.csdn.net/qq_36340642/article/details/79352876)

## 三、实例方法

**总结**

1、test,exec方法每执行一次只匹配一次，即使是在修饰符g的作用下依旧如此，

2、test,exec方法每执行一次只匹配一次，lastIndex就指向下一次匹配开始的位置，因此lastIndex只有在全局模式下才起作用

## 1、test

返回布尔值，用以表示字符串是否匹配正则规则

```js
let reg = /a/igm
let str = 'adsfas'
console.log(reg.test(str))
```

## 2、exec

返回数组，用以返回匹配的结果，包括组匹配的结果

[ 'a', index: 0, input: 'abc', groups: undefined ]

a：匹配的内容

index: 匹配的内容的位置

input为：原字符串的内容

# 三、字符串的正则方法

## 1、replace

## 2、match

# 3、split

## 4、search

将第一次匹配的结果出现的位置index返回，无匹配返回-1

# 四、组匹配

## 1、非捕获组匹配

```javascript
// 非捕获组匹配
let reg = /(foo){1,2}/
let str = 'foofoo'
console.log(str.match(reg))

// [ 'foofoo', 'foo', index: 0, input: 'foofoo', groups: undefined ]

let reg1 = /(?:foo){1,2}/
let str1 = 'foofoo'
console.log(str1.match(reg1))
// [ 'foofoo', index: 0, input: 'foofoo', groups: undefined ]
```

